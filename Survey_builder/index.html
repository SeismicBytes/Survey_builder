<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Survey Parser</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- Keep ALL existing styles from the previous version --- */
        body { font-family: 'Inter', sans-serif; }
        .panel-container { height: calc(100vh - 150px); min-height: 400px; }
        textarea, input[type="text"], input[type="number"], input[type="password"], select { border-radius: 0.375rem; border: 1px solid #d1d5db; padding: 0.5rem 0.75rem; background-color: #fff; font-size: 0.875rem; line-height: 1.25rem; width: 100%; transition: border-color 0.2s; }
        textarea:focus, input:focus, select:focus { outline: 2px solid transparent; outline-offset: 2px; border-color: #4f46e5; box-shadow: 0 0 0 1px #4f46e5; }
        textarea { min-height: 60px; }
        label { display: block; font-weight: 500; margin-bottom: 0.25rem; font-size: 0.875rem; color: #374151; }
        .question-block { border: 1px solid #e5e7eb; border-radius: 0.375rem; padding: 1rem; margin-bottom: 1rem; background-color: #ffffff; box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05); }
        .item-editor-row, .option-item, .validation-item, .detail-item, .next-rule-item { /* Added .next-rule-item */
            display: flex;
            align-items: stretch;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border: 1px dashed #d1d5db;
            border-radius: 0.25rem;
            background-color: #f9fafb;
        }
        .item-editor-row input, .option-item input, .validation-item input, .next-rule-item input { /* Added .next-rule-item input */
             font-size: 0.8rem;
             padding: 0.25rem 0.5rem;
        }
        .item-editor-row button, .validation-item button, .next-rule-item button, .option-item button { /* Added .next-rule-item button */
             align-self: center;
         }
        .small-button { padding: 0.25rem 0.5rem; font-size: 0.75rem; border-radius: 0.25rem; transition: background-color 0.2s; cursor: pointer; white-space: nowrap; }
        .delete-button { background-color: #fee2e2; color: #b91c1c; border: 1px solid #fecaca; } .delete-button:hover { background-color: #fecaca; color: #991b1b; }
        .add-button { background-color: #dbeafe; color: #1d4ed8; border: 1px solid #bfdbfe; margin-top: 0.5rem; } .add-button:hover { background-color: #bfdbfe; color: #1e40af; }
        /* File Input Style */
        input[type="file"]::-webkit-file-upload-button, input[type="file"]::file-selector-button { visibility: hidden; width: 0; height: 0; padding: 0; margin: 0; border: none; }
        input[type="file"]::before { content: 'Upload File'; display: inline-block; background: #4f46e5; color: white; border: none; border-radius: 0.375rem; padding: 0.5rem 1rem; outline: none; white-space: nowrap; cursor: pointer; font-weight: 500; font-size: 0.875rem; transition: background-color 0.2s; margin-right: 0.5rem; }
        input[type="file"]:hover::before { background-color: #4338ca; } input[type="file"]:active::before { background-color: #3730a3; }
        /* Loader */
        .loader { border: 4px solid #f3f4f6; border-top: 4px solid #4f46e5; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; margin-left: 0.5rem; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Header Section (No changes) -->
    <header class="bg-white shadow-sm p-4 flex justify-between items-center sticky top-0 z-10">
        <h1 class="text-xl font-semibold text-indigo-700">Interactive Survey Parser</h1>
        <div class="flex items-center space-x-3">
            <input type="file" id="fileInput" accept=".txt,.docx" class="text-sm">
            <button id="parseButton" class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded-md text-sm transition duration-150 ease-in-out flex items-center disabled:opacity-50 disabled:cursor-not-allowed">
                Parse File
                <span id="loadingIndicator" class="loader hidden"></span>
            </button>
            <button id="saveButton" class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md text-sm transition duration-150 ease-in-out">
                Save JSON
            </button>
            <button id="addQuestionBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-medium py-2 px-4 rounded-md text-sm small-button add-button">Add New Question</button>
        </div>
    </header>

    <!-- Main Content Area (No changes) -->
    <main class="p-4">
        <div id="statusMessage" class="mb-4 p-3 border rounded-md text-sm hidden"></div>
        <div class="flex flex-col md:flex-row gap-4 panel-container">
            <div class="w-full md:w-1/2 flex flex-col">
                <h2 class="text-lg font-medium mb-2 text-gray-700">Raw Text Preview / Paste Area</h2>
                <div class="flex-grow bg-white rounded-md shadow-sm">
                    <textarea id="rawText" class="w-full border-gray-300" placeholder="Select a .txt or .docx file..." spellcheck="false" readonly></textarea>
                </div>
            </div>
            <div class="w-full md:w-1/2 flex flex-col">
                <h2 class="text-lg font-medium mb-2 text-gray-700">Parsed Structure (Editable)</h2>
                 <div id="interactivePanel" class="flex-grow bg-gray-50 border border-gray-200 rounded-md shadow-inner overflow-y-auto p-3">
                    <p class="text-gray-500 italic">Parsed structure will appear here...</p>
                 </div>
            </div>
        </div>
    </main>

    <script>
        // --- DOM Elements & State & Constants (Keep as before) ---
        const fileInput = document.getElementById('fileInput');
        const rawTextArea = document.getElementById('rawText');
        const interactivePanel = document.getElementById('interactivePanel');
        const parseButton = document.getElementById('parseButton');
        const saveButton = document.getElementById('saveButton');
        const statusMessage = document.getElementById('statusMessage');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const addQuestionBtn = document.getElementById('addQuestionBtn');
        let currentParsedData = null;
        const QUESTION_TYPES = ["text", "numeric", "select_one", "select_multiple", "percentage", "currency", "presentation_text", "grid_select_one", "grid_select_multiple", "unknown"];

        // --- Core Helper Functions (Keep showStatus, hideStatus, handleFileUpload, handleSave as before) ---
        function showStatus(message, type = 'info') { statusMessage.textContent = message; statusMessage.classList.remove('hidden', 'bg-yellow-100', 'text-yellow-800', 'border-yellow-300', 'bg-green-100', 'text-green-800', 'border-green-300', 'bg-red-100', 'text-red-800', 'border-red-300', 'bg-blue-100', 'text-blue-800', 'border-blue-300'); switch (type) { case 'success': statusMessage.classList.add('bg-green-100', 'text-green-800', 'border-green-300'); break; case 'warning': statusMessage.classList.add('bg-yellow-100', 'text-yellow-800', 'border-yellow-300'); break; case 'error': statusMessage.classList.add('bg-red-100', 'text-red-800', 'border-red-300'); break; case 'info': default: statusMessage.classList.add('bg-blue-100', 'text-blue-800', 'border-blue-300'); break; } statusMessage.classList.remove('hidden'); }
        function hideStatus() { statusMessage.classList.add('hidden'); statusMessage.textContent = ''; }
        function handleFileUpload(event) { const file = event.target.files[0]; if (!file) { return; } const allowedTypes = ['.txt', '.docx']; const fileExt = file.name.substring(file.name.lastIndexOf('.')).toLowerCase(); if (!allowedTypes.includes(fileExt)) { showStatus(`Invalid file type selected (${fileExt}). Please choose .txt or .docx`, 'warning'); fileInput.value = ''; return; } hideStatus(); interactivePanel.innerHTML = '<p class="text-gray-500 italic">Parsed structure will appear here...</p>'; rawTextArea.value = ''; currentParsedData = null; showStatus(`File '${file.name}' selected. Click 'Parse File' to process.`, 'info'); }
        function handleSave() { if (!currentParsedData) { showStatus('No parsed data available to save...', 'warning'); return; } try { const jsonData = JSON.stringify(currentParsedData, null, 2); const blob = new Blob([jsonData], { type: 'application/json;charset=utf-8;' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; const surveyName = currentParsedData.metadata?.name?.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'survey_output'; const version = currentParsedData.metadata?.version ? `_v${currentParsedData.metadata.version}` : ''; const timestamp = new Date().toISOString().slice(0, 10); link.download = `${surveyName}${version}_${timestamp}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); showStatus('JSON file download initiated.', 'success'); } catch (error) { console.error("Save error:", error); showStatus(`Error preparing file for download: ${error.message}`, 'error'); } }

        // --- Rendering Functions ---
        // Keep renderOptions and renderValidations as before
        function renderOptions(options, questionIndex) { if (!options || options.length === 0) return '<p class="text-xs text-gray-500 italic">No options defined.</p>'; return options.map((opt, optIndex) => ` <div class="option-item" data-opt-index="${optIndex}"> <input type="text" name="optionValue" value="${opt.v}" placeholder="Value (e.g., 1)" class="w-16 text-xs px-1 py-0.5"> <input type="text" name="optionText" value="${opt.t}" placeholder="Option Text" class="flex-grow text-xs px-1 py-0.5"> <button class="delete-option-btn small-button delete-button" data-q-index="${questionIndex}" data-opt-index="${optIndex}">X</button> </div> `).join(''); }
        function renderValidations(validations, questionIndex) { if (!validations || validations.length === 0) { return '<p class="text-xs text-gray-500 italic">No validations defined.</p>'; } return validations.map((val, valIndex) => ` <div class="validation-item" data-val-index="${valIndex}"> <div class="flex-grow"> <label class="text-xs font-normal sr-only" for="val-rule-${questionIndex}-${valIndex}">Rule</label> <input type="text" id="val-rule-${questionIndex}-${valIndex}" name="validationRule" value="${val.rule || ''}" placeholder="Validation Rule (e.g., >0, <100)" class="w-full"> </div> <div class="flex-grow"> <label class="text-xs font-normal sr-only" for="val-msg-${questionIndex}-${valIndex}">Message</label> <input type="text" id="val-msg-${questionIndex}-${valIndex}" name="validationMsg" value="${val.msg || ''}" placeholder="Error Message (Optional)" class="w-full"> </div> <button class="delete-validation-btn small-button delete-button" data-q-index="${questionIndex}" data-val-index="${valIndex}" aria-label="Delete Validation Rule">X</button> </div> `).join('');}

        /**
         * NEW: Renders HTML for the next logic (skip rules) of a question.
         * @param {object} nextLogic - The next logic object (e.g., {"1": "@Q2", "@DEFAULT": "@NEXT"})
         * @param {number} questionIndex - The index of the parent question.
         * @returns {string} HTML string for the next logic rules.
         */
        function renderNextLogic(nextLogic, questionIndex) {
            const rules = Object.entries(nextLogic || {}); // Convert {key:val} to [[key,val], ...]
            if (rules.length === 0) {
                return '<p class="text-xs text-gray-500 italic">No skip logic defined (sequential flow).</p>';
            }

            return rules.map(([condition, action], ruleIndex) => `
                <div class="next-rule-item" data-rule-condition-key="${condition}"> <!-- Use original condition as key for deletion -->
                    <div class="flex-grow">
                        <label class="text-xs font-normal sr-only" for="next-condition-${questionIndex}-${ruleIndex}">Condition/Answer:</label>
                        <input type="text" id="next-condition-${questionIndex}-${ruleIndex}" name="nextConditionKey" value="${condition}" placeholder="Condition (e.g., 1, @DEFAULT, @AGE > 40)" class="w-full">
                    </div>
                    <span class="self-center text-gray-600 text-sm">then go to</span>
                    <div class="flex-grow">
                        <label class="text-xs font-normal sr-only" for="next-action-${questionIndex}-${ruleIndex}">Action/Target QID:</label>
                        <input type="text" id="next-action-${questionIndex}-${ruleIndex}" name="nextActionValue" value="${action}" placeholder="Target (e.g., @Q101.0010, @NEXT)" class="w-full">
                    </div>
                    <button class="delete-next-rule-btn small-button delete-button" data-q-index="${questionIndex}" data-rule-condition-key="${condition}" aria-label="Delete Skip Rule">X</button>
                </div>
            `).join('');
        }

        /**
         * MODIFIED: Renders the entire parsed data structure, including the new next logic section.
         */
        function renderParsedData(data) {
            // ... (Keep metadata rendering part as before) ...
            if (!data) { interactivePanel.innerHTML = '<p class="text-red-600">Error: No data to render.</p>'; return; } interactivePanel.innerHTML = ''; if (data.metadata && typeof data.metadata === 'object') { const metaDiv = document.createElement('div'); metaDiv.className = 'mb-6 p-4 border border-gray-200 rounded-md bg-white shadow-sm'; metaDiv.innerHTML = '<h3 class="text-lg font-semibold mb-3 text-indigo-700 border-b pb-2">Metadata</h3>'; const gridDiv = document.createElement('div'); gridDiv.className = 'grid grid-cols-2 gap-4'; for (const key in data.metadata) { const value = data.metadata[key]; const itemDiv = document.createElement('div'); itemDiv.innerHTML = ` <label for="meta-${key}" class="block text-sm font-medium text-gray-700">${key.replace(/_/g, ' ')}:</label> <input type="text" id="meta-${key}" name="${key}" value="${value || ''}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 text-sm bg-gray-50" readonly title="Metadata editing not implemented yet"> `; gridDiv.appendChild(itemDiv); } metaDiv.appendChild(gridDiv); interactivePanel.appendChild(metaDiv); }

            if (data.questions && Array.isArray(data.questions)) {
                data.questions.forEach((question, index) => {
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'question-block';
                    questionDiv.setAttribute('data-q-index', index);

                    // --- Core question fields (ID, Delete, Text, Type) ---
                    questionDiv.innerHTML = `
                        <div class="flex justify-between items-center mb-3 border-b pb-2">
                            <h4 class="text-md font-semibold text-gray-800">Question ID: <input type="text" name="id" value="${question.id || ''}" class="font-mono bg-gray-100 px-1 rounded text-sm w-32 inline-block ml-1 border-gray-300"></h4>
                            <button class="delete-question-btn small-button delete-button" data-q-index="${index}">Delete Question</button>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div> <label for="q-text-${index}">Question Text:</label> <textarea id="q-text-${index}" name="question" rows="3">${question.question || ''}</textarea> </div>
                            <div> <label for="q-type-${index}">Question Type:</label> <select id="q-type-${index}" name="type"> ${QUESTION_TYPES.map(type => `<option value="${type}" ${question.type === type ? 'selected' : ''}>${type}</option>`).join('')} </select> </div>
                        </div>
                    `;

                    // --- Options Section ---
                    const optionsSection = document.createElement('div');
                    optionsSection.className = `options-section mb-4 ${question.type?.startsWith('select') || question.type?.startsWith('grid') ? '' : 'hidden'}`;
                    optionsSection.innerHTML = ` <label class="font-medium text-gray-700">${question.type?.startsWith('grid') ? 'Row Items/Options:' : 'Options:'}</label> <div id="options-container-${index}" class="mt-2 space-y-2"> ${renderOptions(question.options || [], index)} </div> <button class="add-option-btn small-button add-button" data-q-index="${index}">+ Add Option/Row</button> `;
                    questionDiv.appendChild(optionsSection);

                    // --- Other Fields (Hovertexts, Prog Details) ---
                    const otherFieldsSection = document.createElement('div');
                    otherFieldsSection.className = 'grid grid-cols-1 md:grid-cols-2 gap-4 mb-4';
                    otherFieldsSection.innerHTML = ` <div> <label for="q-hovertexts-${index}">Hovertexts (Raw):</label> <textarea id="q-hovertexts-${index}" name="hovertexts" rows="2" placeholder="Enter raw hovertext content...">${question.hovertexts || ''}</textarea> </div> <div> <label for="q-prog-details-${index}">Programming Details:</label> <textarea id="q-prog-details-${index}" name="programming_details" rows="2" placeholder="Enter details one per line...">${(question.programming_details || []).join('\n')}</textarea> </div> `;
                    questionDiv.appendChild(otherFieldsSection);

                    // --- Validations Section ---
                    const validationsSection = document.createElement('div');
                    validationsSection.className = 'validations-section mb-4'; // Added mb-4 for spacing
                    validationsSection.innerHTML = ` <label class="font-medium text-gray-700">Validations:</label> <div id="validations-container-${index}" class="mt-2 space-y-2"> ${renderValidations(question.validations || [], index)} </div> <button class="add-validation-btn small-button add-button" data-q-index="${index}">+ Add Validation</button> `;
                    questionDiv.appendChild(validationsSection);

                    // --- ** NEW: Create and Append Next Logic (Skip Rules) Section ** ---
                    const nextLogicSection = document.createElement('div');
                    nextLogicSection.className = 'next-logic-section mt-4';
                    nextLogicSection.innerHTML = `
                        <label class="font-medium text-gray-700">Skip Logic / Next Question:</label>
                        <div id="next-logic-container-${index}" class="mt-2 space-y-2">
                            ${renderNextLogic(question.next || {}, index)}
                        </div>
                        <button class="add-next-rule-btn small-button add-button" data-q-index="${index}">+ Add Skip Rule</button>
                    `;
                    questionDiv.appendChild(nextLogicSection);
                    // --- End Next Logic Section ---

                    interactivePanel.appendChild(questionDiv);
                });
            } else {
                 interactivePanel.innerHTML += '<p class="text-gray-500">No questions found in data.</p>';
            }
            attachEventListeners(); // Attach listeners after all HTML is in DOM
        }

        // --- Event Handling Functions ---
        // Keep: handleAddQuestion, handleDeleteQuestion, handleAddOption, handleDeleteOption, handleAddValidation, handleDeleteValidation
        function handleAddQuestion() { if (!currentParsedData) { currentParsedData = { metadata: {}, questions: [] }; } if (!currentParsedData.questions) { currentParsedData.questions = []; } const newQuestion = { id: `NEW_Q_${currentParsedData.questions.length + 1}`, question: "", type: "text", options: [], hovertexts: null, probes: {}, next: {}, validations: [], programming_details: [] }; currentParsedData.questions.push(newQuestion); showStatus(`Added new question ${newQuestion.id}. Scroll down to edit.`, 'success'); renderParsedData(currentParsedData); }
        function handleDeleteQuestion(event) { const button = event.target; const qIndex = parseInt(button.dataset.qIndex); if (isNaN(qIndex) || !currentParsedData?.questions[qIndex]) return; const questionId = currentParsedData.questions[qIndex].id || `at index ${qIndex}`; if (confirm(`Are you sure you want to delete question ${questionId}?`)) { currentParsedData.questions.splice(qIndex, 1); showStatus(`Deleted question ${questionId}.`, 'info'); renderParsedData(currentParsedData); } }
        function handleAddOption(event) { const button = event.target; const qIndex = parseInt(button.dataset.qIndex); if (isNaN(qIndex) || !currentParsedData?.questions[qIndex]) return; const question = currentParsedData.questions[qIndex]; if (!question.options) { question.options = []; } const newOption = { v: question.options.length + 1, t: "New Option" }; question.options.push(newOption); const optionsContainer = interactivePanel.querySelector(`#options-container-${qIndex}`); if (optionsContainer) { optionsContainer.innerHTML = renderOptions(question.options, qIndex); optionsContainer.querySelectorAll('.delete-option-btn').forEach(btn => { btn.removeEventListener('click', handleDeleteOption); btn.addEventListener('click', handleDeleteOption); }); optionsContainer.querySelectorAll('input').forEach(input => { input.removeEventListener('change', handleInputChange); input.addEventListener('change', handleInputChange); }); } else { renderParsedData(currentParsedData); } showStatus('Added new option.', 'info'); }
        function handleDeleteOption(event) { const button = event.target; const qIndex = parseInt(button.dataset.qIndex); const optIndex = parseInt(button.dataset.optIndex); if (isNaN(qIndex) || isNaN(optIndex) || !currentParsedData?.questions[qIndex]?.options[optIndex]) return; const question = currentParsedData.questions[qIndex]; question.options.splice(optIndex, 1); const optionsContainer = interactivePanel.querySelector(`#options-container-${qIndex}`); if (optionsContainer) { optionsContainer.innerHTML = renderOptions(question.options, qIndex); optionsContainer.querySelectorAll('.delete-option-btn').forEach(btn => { btn.removeEventListener('click', handleDeleteOption); btn.addEventListener('click', handleDeleteOption); }); optionsContainer.querySelectorAll('input').forEach(input => { input.removeEventListener('change', handleInputChange); input.addEventListener('change', handleInputChange); }); } else { renderParsedData(currentParsedData); } showStatus('Deleted option.', 'info'); }
        function handleAddValidation(event) { const button = event.target; const qIndex = parseInt(button.dataset.qIndex); if (isNaN(qIndex) || !currentParsedData?.questions[qIndex]) return; const question = currentParsedData.questions[qIndex]; if (!question.validations) { question.validations = []; } const newValidation = { rule: "", msg: null }; question.validations.push(newValidation); const validationsContainer = interactivePanel.querySelector(`#validations-container-${qIndex}`); if (validationsContainer) { validationsContainer.innerHTML = renderValidations(question.validations, qIndex); validationsContainer.querySelectorAll('.delete-validation-btn').forEach(btn => { btn.removeEventListener('click', handleDeleteValidation); btn.addEventListener('click', handleDeleteValidation); }); validationsContainer.querySelectorAll('input').forEach(input => { input.removeEventListener('change', handleInputChange); input.addEventListener('change', handleInputChange); }); } else { renderParsedData(currentParsedData); } showStatus('Added new validation rule.', 'info'); }
        function handleDeleteValidation(event) { const button = event.target; const qIndex = parseInt(button.dataset.qIndex); const valIndex = parseInt(button.dataset.valIndex); if (isNaN(qIndex) || isNaN(valIndex) || !currentParsedData?.questions[qIndex]?.validations[valIndex]) return; const question = currentParsedData.questions[qIndex]; question.validations.splice(valIndex, 1); const validationsContainer = interactivePanel.querySelector(`#validations-container-${qIndex}`); if (validationsContainer) { validationsContainer.innerHTML = renderValidations(question.validations, qIndex); validationsContainer.querySelectorAll('.delete-validation-btn').forEach(btn => { btn.removeEventListener('click', handleDeleteValidation); btn.addEventListener('click', handleDeleteValidation); }); validationsContainer.querySelectorAll('input').forEach(input => { input.removeEventListener('change', handleInputChange); input.addEventListener('change', handleInputChange); }); } else { renderParsedData(currentParsedData); } showStatus('Deleted validation rule.', 'info'); }

        /**
         * NEW: Handles adding a default skip rule to a question and re-rendering its skip logic.
         */
        function handleAddNextRule(event) {
            const button = event.target;
            const qIndex = parseInt(button.dataset.qIndex);
            if (isNaN(qIndex) || !currentParsedData?.questions[qIndex]) return;

            const question = currentParsedData.questions[qIndex];
            if (!question.next) { // Ensure 'next' object exists
                question.next = {};
            }

            // Add a new default rule (e.g., @DEFAULT -> @NEXT or an empty condition)
            // To avoid overwriting, we need a unique key if user doesn't change it.
            // For now, let's prompt for a simple condition key.
            const newConditionKey = prompt("Enter condition key (e.g., '@DEFAULT', '1', 'answer > 40'):", "@DEFAULT");
            if (newConditionKey === null) return; // User cancelled prompt

            if (question.next.hasOwnProperty(newConditionKey.trim())) {
                showStatus(`Condition key '${newConditionKey.trim()}' already exists for this question. Please use a unique key.`, 'warning');
                return;
            }
            question.next[newConditionKey.trim()] = "@NEXT"; // Default action

            // Partial re-render
            const nextLogicContainer = interactivePanel.querySelector(`#next-logic-container-${qIndex}`);
            if (nextLogicContainer) {
                nextLogicContainer.innerHTML = renderNextLogic(question.next, qIndex);
                nextLogicContainer.querySelectorAll('.delete-next-rule-btn').forEach(btn => {
                    btn.removeEventListener('click', handleDeleteNextRule); btn.addEventListener('click', handleDeleteNextRule);
                });
                nextLogicContainer.querySelectorAll('input').forEach(input => {
                    input.removeEventListener('change', handleInputChange); input.addEventListener('change', handleInputChange);
                });
            } else {
                renderParsedData(currentParsedData);
            }
            showStatus('Added new skip rule.', 'info');
        }


        /**
         * NEW: Handles deleting a skip rule from a question and re-rendering.
         */
        function handleDeleteNextRule(event) {
            const button = event.target;
            const qIndex = parseInt(button.dataset.qIndex);
            const ruleConditionKey = button.dataset.ruleConditionKey; // The key of the rule to delete

            if (isNaN(qIndex) || !ruleConditionKey || !currentParsedData?.questions[qIndex]?.next) return;

            const question = currentParsedData.questions[qIndex];
            if (question.next.hasOwnProperty(ruleConditionKey)) {
                delete question.next[ruleConditionKey]; // Delete the property from the object

                // Partial re-render
                const nextLogicContainer = interactivePanel.querySelector(`#next-logic-container-${qIndex}`);
                if (nextLogicContainer) {
                    nextLogicContainer.innerHTML = renderNextLogic(question.next, qIndex);
                    nextLogicContainer.querySelectorAll('.delete-next-rule-btn').forEach(btn => {
                        btn.removeEventListener('click', handleDeleteNextRule); btn.addEventListener('click', handleDeleteNextRule);
                    });
                    nextLogicContainer.querySelectorAll('input').forEach(input => {
                        input.removeEventListener('change', handleInputChange); input.addEventListener('change', handleInputChange);
                    });
                } else {
                    renderParsedData(currentParsedData);
                }
                showStatus(`Deleted skip rule for condition '${ruleConditionKey}'.`, 'info');
            } else {
                 showStatus(`Skip rule for condition '${ruleConditionKey}' not found.`, 'warning');
            }
        }


        /**
         * MODIFIED: Attaches event listeners, including for new next logic elements.
         */
        function attachEventListeners() {
            // Remove previous listeners before attaching new ones to prevent duplicates on re-render
            interactivePanel.querySelectorAll('textarea, input, select').forEach(element => {
                element.removeEventListener('change', handleInputChange); element.addEventListener('change', handleInputChange);
            });
            interactivePanel.querySelectorAll('.delete-question-btn').forEach(btn => { btn.removeEventListener('click', handleDeleteQuestion); btn.addEventListener('click', handleDeleteQuestion); });
            interactivePanel.querySelectorAll('.add-option-btn').forEach(btn => { btn.removeEventListener('click', handleAddOption); btn.addEventListener('click', handleAddOption); });
            interactivePanel.querySelectorAll('.delete-option-btn').forEach(btn => { btn.removeEventListener('click', handleDeleteOption); btn.addEventListener('click', handleDeleteOption); });
            interactivePanel.querySelectorAll('.add-validation-btn').forEach(btn => { btn.removeEventListener('click', handleAddValidation); btn.addEventListener('click', handleAddValidation); });
            interactivePanel.querySelectorAll('.delete-validation-btn').forEach(btn => { btn.removeEventListener('click', handleDeleteValidation); btn.addEventListener('click', handleDeleteValidation); });

            // ** NEW: Add listeners for Next Logic (Skip Rule) buttons **
            interactivePanel.querySelectorAll('.add-next-rule-btn').forEach(button => {
                 button.removeEventListener('click', handleAddNextRule);
                 button.addEventListener('click', handleAddNextRule);
            });
            interactivePanel.querySelectorAll('.delete-next-rule-btn').forEach(button => {
                button.removeEventListener('click', handleDeleteNextRule);
                button.addEventListener('click', handleDeleteNextRule);
            });
        }


        /**
         * MODIFIED: Handles input changes, now includes nextConditionKey and nextActionValue.
         * Also handles potential changes to the condition key for skip logic.
         */
        function handleInputChange(event) {
            const element = event.target;
            const questionBlock = element.closest('.question-block');
            if (!questionBlock) return;

            const qIndex = parseInt(questionBlock.dataset.qIndex);
            if (isNaN(qIndex) || !currentParsedData?.questions[qIndex]) return;

            const fieldName = element.name;
            const value = element.value;
            const question = currentParsedData.questions[qIndex];

            if (fieldName === 'id' || fieldName === 'question' || fieldName === 'type' || fieldName === 'hovertexts') {
                question[fieldName] = value;
            } else if (fieldName === 'programming_details') {
                 question[fieldName] = value.split('\n').map(s => s.trim()).filter(Boolean);
            } else if (fieldName === 'optionValue' || fieldName === 'optionText') {
                const optionItem = element.closest('.option-item'); if (!optionItem) return;
                const optIndex = parseInt(optionItem.dataset.optIndex); if (isNaN(optIndex) || !question.options[optIndex]) return;
                if (fieldName === 'optionValue') question.options[optIndex].v = value;
                if (fieldName === 'optionText') question.options[optIndex].t = value;
            } else if (fieldName === 'validationRule' || fieldName === 'validationMsg') {
                const validationItem = element.closest('.validation-item'); if (!validationItem) return;
                const valIndex = parseInt(validationItem.dataset.valIndex); if (isNaN(valIndex) || !question.validations[valIndex]) return;
                if (fieldName === 'validationRule') question.validations[valIndex].rule = value;
                else if (fieldName === 'validationMsg') question.validations[valIndex].msg = value.trim() || null;
            }
            // ** NEW: Handle skip logic rule changes **
            else if (fieldName === 'nextConditionKey' || fieldName === 'nextActionValue') {
                const ruleItem = element.closest('.next-rule-item'); if (!ruleItem) return;
                const originalConditionKey = ruleItem.dataset.ruleConditionKey; // Get the key as it was when rendered

                if (!question.next || !question.next.hasOwnProperty(originalConditionKey)) {
                    console.warn(`Original condition key '${originalConditionKey}' not found in question.next for Q${qIndex}. This might happen if key was just changed.`);
                    // If the original key is not found, it might have just been edited.
                    // We need to find the rule by another means or assume it's a new rule if adding.
                    // For simplicity now, this edit path might fail if the key itself changed.
                    // A more robust solution would track rules by an internal index.
                    // For now, let's assume key changes aren't directly handled by this 'change' event flow on the key input itself.
                    // The handleDeleteNextRule and handleAddNextRule manage the keys.
                    // This primarily handles changes to the ACTION VALUE for an EXISTING KEY.
                    if(fieldName === 'nextActionValue' && question.next.hasOwnProperty(originalConditionKey)){
                        question.next[originalConditionKey] = value;
                    } else if (fieldName === 'nextConditionKey') {
                        // User is trying to change the condition key itself
                        const newConditionKey = value.trim();
                        const actionValue = question.next[originalConditionKey]; // Get old action

                        if (newConditionKey && newConditionKey !== originalConditionKey) {
                            if (question.next.hasOwnProperty(newConditionKey)) {
                                showStatus(`Cannot change condition to '${newConditionKey}'. It already exists. Delete old one first.`, 'warning');
                                element.value = originalConditionKey; // Revert change
                                return;
                            }
                            delete question.next[originalConditionKey]; // Delete old key
                            question.next[newConditionKey] = actionValue; // Add new key with old value
                            ruleItem.dataset.ruleConditionKey = newConditionKey; // Update the data attribute for future edits/deletes
                            showStatus(`Condition key changed from '${originalConditionKey}' to '${newConditionKey}'.`, 'info');
                        } else if (!newConditionKey) {
                             showStatus('Condition key cannot be empty.', 'warning');
                             element.value = originalConditionKey; // Revert
                             return;
                        }
                    }
                } else if (fieldName === 'nextActionValue') {
                    question.next[originalConditionKey] = value;
                }
            }


            console.log(`Updated Q${qIndex}.${fieldName}`);
            showStatus('Changes made. Remember to Save JSON when finished.', 'info');

            if (fieldName === 'type') { /* ... (type change logic as before) ... */
                 const optionsSection = questionBlock.querySelector('.options-section'); if (value?.startsWith('select') || value?.startsWith('grid')) { optionsSection?.classList.remove('hidden'); } else { optionsSection?.classList.add('hidden'); }
            }
        }


        // --- Main API Call Function (Keep handleParse as before) ---
        async function handleParse() { if (fileInput.files.length === 0) { showStatus('Please select a .txt or .docx file first...', 'warning'); return; } const file = fileInput.files[0]; const allowedTypes = ['.txt', '.docx']; const fileExt = file.name.substring(file.name.lastIndexOf('.')).toLowerCase(); if (!allowedTypes.includes(fileExt)) { showStatus(`Unsupported file type: ${fileExt}. Please upload .txt or .docx`, 'error'); return; } showStatus(`Parsing file '${file.name}' (calling backend API)...`, 'info'); parseButton.disabled = true; loadingIndicator.classList.remove('hidden'); interactivePanel.innerHTML = '<p class="text-gray-500 italic p-4">Sending file to backend for parsing... Please wait.</p>'; currentParsedData = null; const apiUrl = 'http://localhost:5000/parse'; const runId = `UI-${Date.now()}`; const formData = new FormData(); formData.append('file', file); formData.append('run_id', runId); try { const response = await fetch(apiUrl, { method: 'POST', body: formData, }); console.log("API Response Status:", response.status, response.statusText); if (!response.ok) { let errorMsg = `API Error: ${response.status} ${response.statusText}`; try { const errorData = await response.json(); if (errorData && errorData.error) { errorMsg = `API Error (${response.status}): ${errorData.error}`; } } catch (e) { console.warn("Could not parse error response JSON:", e); } throw new Error(errorMsg); } const resultData = await response.json(); currentParsedData = resultData; renderParsedData(currentParsedData); showStatus(`File '${file.name}' parsed successfully. Displaying interactive structure.`, 'success'); } catch (error) { console.error("Parsing API call error:", error); showStatus(`Parsing failed: ${error.message || 'Network error or backend unreachable.'}`, 'error'); interactivePanel.innerHTML = `<p class="text-red-600 p-4">Error during parsing: ${error.message || 'Check console/server logs.'}</p>`; } finally { parseButton.disabled = false; loadingIndicator.classList.add('hidden'); } }

        // --- Event Listeners ---
        fileInput.addEventListener('change', handleFileUpload);
        parseButton.addEventListener('click', handleParse);
        saveButton.addEventListener('click', handleSave);
        addQuestionBtn.addEventListener('click', handleAddQuestion);

        // --- Initial Setup ---
        showStatus('Ready. Select a .txt or .docx file, then click "Parse File".', 'info');
    </script>

</body>
</html>